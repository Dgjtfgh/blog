/*
SQLyog Community v13.1.6 (64 bit)
MySQL - 8.0.17 : Database - myblog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`myblog` /*!40100 DEFAULT CHARACTER SET utf8 */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `myblog`;

/*Table structure for table `admin_user` */

DROP TABLE IF EXISTS `admin_user`;

CREATE TABLE `admin_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `userName` char(50) DEFAULT NULL,
  `password` varchar(50) DEFAULT NULL,
  `qq` varchar(50) DEFAULT NULL,
  `githubUrl` varchar(500) DEFAULT NULL,
  `introduce` varchar(5000) DEFAULT NULL,
  `portrait` varchar(500) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `admin_user` */

insert  into `admin_user`(`id`,`userName`,`password`,`qq`,`githubUrl`,`introduce`,`portrait`) values 
(1,'Dgjtfgh','981128','1137807913','https://github.com/Dgjtfgh','东华理工大学软件学院大四学生，编程新人小白一枚','https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=597090540,2799401554&fm=11&gp=0.jpg');

/*Table structure for table `article` */

DROP TABLE IF EXISTS `article`;

CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `type_id` int(11) NOT NULL,
  `title` varchar(255) NOT NULL,
  `article_content` text NOT NULL,
  `introduce` text,
  `addTime` int(11) DEFAULT NULL,
  `view_count` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;

/*Data for the table `article` */

insert  into `article`(`id`,`type_id`,`title`,`article_content`,`introduce`,`addTime`,`view_count`) values 
(1,1,'React实战学习','<MEMO>','React的基础和全家桶都已经讲完了，是时候把所有知识都串联起来，作一个真实项目了。 项目要用到的技术栈会很多，而且是真实项目，开发完成后，我会把自己的博客替换成新开发的，并且会把代码进行开源。 项目前台会使用React服务端渲染，并且全部使用Hooks语法来完成。 项目后台可能会使用Koa+mysql,后台将使用Koa的上层框架egg.js。',1234567895,2),
(2,1,'React实战学习','### 前言\n学习理解vue的各属性，准确使用属性给我们更好的开发体验。\n新人一枚，简单的学习分享，请各位大佬指点\n### 简单理解\n    属性写法          名称                作用\n    data: {}         数据属性         用来存放需要绑定的数据\n    methods: {}      事件操作属性     用来放定义的事件方法\n    components: {}   组件属性         自定义组件声明\n    props: {}         获取父组件数据   单向绑定\n    computed: {}     计算属性         提供相对简单的数据计算\n    watch: {}        侦听器           观察某一特定question的值  \n    directives: {}   自定义指令属性   注册内部自定义指令\n    filters: {}      过滤器           自定义过滤器\n    ...\n**data  methods components**  三个属性学习vue最常用到的，大家都比较熟悉，这里就不多说了。\n### 用一个简单的例子介绍下computed, watch, filter的用法区别\n#### 1.侦听属性 watch\nwatch 监听某一特定值，数据发生变化出发事件，做出相应的改变\n##### 看实现结果\n```\n<input data-id=\"1\" style=\"color: green\" v-model=\"info1\" v-focus>\n```\n```\ndata() {\n    return {\n      info1: \'\',\n      info2: \'\',\n      connectInfos: \'\'\n    }\n  },\nwatch: {\n    info1: function(newInfo, oldInfo) {\n      console.log(\"旧值：\", oldInfo);\n      console.log(\"新值：\", newInfo);\n    }\n  },\n```\nwatch属性带有两个参数，第一个参数为改变后的值，第二个参数为改变前的值。\n\n* \n![](https://user-gold-cdn.xitu.io/2020/3/8/170b8bcd4c935778?w=532&h=160&f=png&s=10047)\n#### 2.计算属性 computed\n既然是计算，肯定存在**依赖关系**，计算所依赖的参数改变了，结果也会随之改变。所以属性值的依赖属性改变了会触发事件更新其本身。\n\n计算除了直接设置为方法，可以通过**getter setter** 方法进行操作\n```\n<p >\n      字段1:\n      <input data-id=\"1\" style=\"color: green\" v-model=\"info1\" v-focus>\n      字段2:\n      <input data-id=\"2\" style=\"color: green\" v-model=\"info2\" >\n    </p>\n    <p id=\"computed-example\">连接: {{ connectInfo }}</p>\n```\n\n```\ncomputed: {\n    // 计算属性的 getter\n    connectInfo: function () {\n      // `this` 指向 vm 实例\n      this.connectInfos = this.info1 + this.info2;\n      return this.connectInfos;\n    }\n  },\n```\n运行结果\n\n* \n\n![](https://user-gold-cdn.xitu.io/2020/3/8/170b8de202065f55?w=468&h=95&f=gif&s=6594)\ncomputed 与 wacth 区别可以参考 https://juejin.im/entry/6844904074643685384\n作者用了一个简单的加法实例，直观展现。\n\n#### 3.过滤器属性 filters\nvue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器渲染格式化不会改变其本身的文本内容，它只改变输出。\n\n过滤器用在差值表达式{{}}和v-bind表达式中，由**管道操作符** ’|‘指示。\n\n```\n<p id=\"filters-example\">全部大写: {{connectInfos | capitalize}}</p>\n```\n\n```\nfilters: {\n    capitalize(word) {\n      return word.toUpperCase();\n    }\n  },\n```\n**管道操作符：**  符号前是符号后执行的内容\n\n### props 属性\n组件是vue的一大功能，因此组件通信很关键了，poros属性用于组件的通信。\n\n**直接看代码趴**\n\n##### 静态绑定：\n父组件\n```\n<Child info=\"hello\"></Child>\n```\n\n```\nimport child from \"./components/child_component\"\n```\n\n```\ncomponents: {\n    Child: child\n  },\n```\n子组件\n```\n<template>\n    <div id=\"child\">\n    <p>子组件</p>\n    <p>{{info}}</p>\n  </div>\n</template>\n <<script>\n export default {\n     props: [\'info\']\n }\n </script>\n```\n\n* \n![](https://user-gold-cdn.xitu.io/2020/3/8/170b916ce603c26e?w=269&h=83&f=png&s=1440)\n##### 动态绑定：\n父组件(改)\n```\n<Child :info=\"connectInfos\"></Child>\n```\n\n![](https://user-gold-cdn.xitu.io/2020/3/8/170b91ad5f8a7a2c?w=256&h=183&f=gif&s=5468)\n用于组件通信的还有:\n\n    $ref: 也是父组件向子组件通信的，主要用来调用子组件里的属性和方法。\n    $emit：实现子组件向父组件通信，主要绑定一个自定义事件响应给父组件。\n    props: 主要注重数据传送，不能调用子组件里的属性和方法。\n\n### 浅谈 directives\nvue.js提供的自定义指令还是很有意思的，有很强的复用性。自定义指令和组件、过滤器一样有全局注册和局部注册两种。\n\n官方文档的钩子函数： \nhttps://cn.vuejs.org/v2/guide/custom-directive.html\n\n代码查看下参数：\n```\n// 全局定义  绝对定位自定义指令\nVue.directive(\'abLocal\', {\n  // 指令第一次绑定到元素时\n  bind(el, binding, vnode) {\n    console.log(\"el:\", el);\n        console.log(el.style);\n        console.log(\"color:\", el.style.color);\n        console.log(\"data-id:\", el.dataset.id);\n        console.log(binding);\n        console.log(vnode);\n    el.style.position = \'absolute\';\n    el.style.top = binding.value.top+\'px\';\n    el.style.left = binding.value.left+\'px\';\n  }\n})\n```\n\n```\n<template>\n  <div id=\"app\" data-id=\"0\" style=\"color: green\"  v-abLocal=\"{top: \'50\', left: \'100\'}\">   \n    <p >\n      字段1:\n      <input data-id=\"1\" style=\"color: green\" v-model=\"info1\" v-focus>\n      字段2:\n      <input data-id=\"2\" style=\"color: green\" v-model=\"info2\" >\n    </p>\n    <p id=\"computed-example\">连接: {{ connectInfo }}</p>\n    <p id=\"filters-example\">全部大写: {{connectInfos | capitalize}}</p>\n    <Child :info=\"connectInfos\"></Child>\n  </div>\n</template> \n```\n\n参数 **el**:\n* \n![](https://user-gold-cdn.xitu.io/2020/3/8/170b94f118d41b89?w=584&h=275&f=png&s=20372)\n可以看到绝对定位的样式 **{position: absolute; top: 50px; left: 100px}**  被添加进去了\n参数 **binging**\n* \n![](https://user-gold-cdn.xitu.io/2020/3/8/170b953ca7c01145?w=601&h=157&f=png&s=12886)\n传入的值{top: \'50\', left: \'100\'} 再binding.value中拿到了。\n### 最后\n只是很浅的理解，还需要更深入的学习。文章有不妥的地方请大家指正。','React实战学习，自我学习',1598976000,6),
(4,1,'vue常用属性','### 前言\n学习理解vue的各属性，准确使用属性给我们更好的开发体验。\n新人一枚，简单的学习分享，请各位大佬指点\n### 简单理解\n    属性写法          名称                作用\n    data: {}         数据属性         用来存放需要绑定的数据\n    methods: {}      事件操作属性     用来放定义的事件方法\n    components: {}   组件属性         自定义组件声明\n    props: {}         获取父组件数据   单向绑定\n    computed: {}     计算属性         提供相对简单的数据计算\n    watch: {}        侦听器           观察某一特定question的值  \n    directives: {}   自定义指令属性   注册内部自定义指令\n    filters: {}      过滤器           自定义过滤器\n    ...\n**data  methods components**  三个属性学习vue最常用到的，大家都比较熟悉，这里就不多说了。\n### 用一个简单的例子介绍下computed, watch, filter的用法区别\n#### 1.侦听属性 watch\nwatch 监听某一特定值，数据发生变化出发事件，做出相应的改变\n##### 看实现结果\n```\n<input data-id=\"1\" style=\"color: green\" v-model=\"info1\" v-focus>\n```\n```\ndata() {\n    return {\n      info1: \'\',\n      info2: \'\',\n      connectInfos: \'\'\n    }\n  },\nwatch: {\n    info1: function(newInfo, oldInfo) {\n      console.log(\"旧值：\", oldInfo);\n      console.log(\"新值：\", newInfo);\n    }\n  },\n```\nwatch属性带有两个参数，第一个参数为改变后的值，第二个参数为改变前的值。\n\n* \n![](https://user-gold-cdn.xitu.io/2020/3/8/170b8bcd4c935778?w=532&h=160&f=png&s=10047)\n#### 2.计算属性 computed\n既然是计算，肯定存在**依赖关系**，计算所依赖的参数改变了，结果也会随之改变。所以属性值的依赖属性改变了会触发事件更新其本身。\n\n计算除了直接设置为方法，可以通过**getter setter** 方法进行操作\n```\n<p >\n      字段1:\n      <input data-id=\"1\" style=\"color: green\" v-model=\"info1\" v-focus>\n      字段2:\n      <input data-id=\"2\" style=\"color: green\" v-model=\"info2\" >\n    </p>\n    <p id=\"computed-example\">连接: {{ connectInfo }}</p>\n```\n\n```\ncomputed: {\n    // 计算属性的 getter\n    connectInfo: function () {\n      // `this` 指向 vm 实例\n      this.connectInfos = this.info1 + this.info2;\n      return this.connectInfos;\n    }\n  },\n```\n运行结果\n\n* \n\n![](https://user-gold-cdn.xitu.io/2020/3/8/170b8de202065f55?w=468&h=95&f=gif&s=6594)\ncomputed 与 wacth 区别可以参考 https://juejin.im/entry/6844904074643685384\n作者用了一个简单的加法实例，直观展现。\n\n#### 3.过滤器属性 filters\nvue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器渲染格式化不会改变其本身的文本内容，它只改变输出。\n\n过滤器用在差值表达式{{}}和v-bind表达式中，由**管道操作符** ’|‘指示。\n\n```\n<p id=\"filters-example\">全部大写: {{connectInfos | capitalize}}</p>\n```\n\n```\nfilters: {\n    capitalize(word) {\n      return word.toUpperCase();\n    }\n  },\n```\n**管道操作符：**  符号前是符号后执行的内容\n\n### props 属性\n组件是vue的一大功能，因此组件通信很关键了，poros属性用于组件的通信。\n\n**直接看代码趴**\n\n##### 静态绑定：\n父组件\n```\n<Child info=\"hello\"></Child>\n```\n\n```\nimport child from \"./components/child_component\"\n```\n\n```\ncomponents: {\n    Child: child\n  },\n```\n子组件\n```\n<template>\n    <div id=\"child\">\n    <p>子组件</p>\n    <p>{{info}}</p>\n  </div>\n</template>\n <<script>\n export default {\n     props: [\'info\']\n }\n </script>\n```\n\n* \n![](https://user-gold-cdn.xitu.io/2020/3/8/170b916ce603c26e?w=269&h=83&f=png&s=1440)\n##### 动态绑定：\n父组件(改)\n```\n<Child :info=\"connectInfos\"></Child>\n```\n\n![](https://user-gold-cdn.xitu.io/2020/3/8/170b91ad5f8a7a2c?w=256&h=183&f=gif&s=5468)\n用于组件通信的还有:\n\n    $ref: 也是父组件向子组件通信的，主要用来调用子组件里的属性和方法。\n    $emit：实现子组件向父组件通信，主要绑定一个自定义事件响应给父组件。\n    props: 主要注重数据传送，不能调用子组件里的属性和方法。\n\n### 浅谈 directives\nvue.js提供的自定义指令还是很有意思的，有很强的复用性。自定义指令和组件、过滤器一样有全局注册和局部注册两种。\n\n官方文档的钩子函数： \nhttps://cn.vuejs.org/v2/guide/custom-directive.html\n\n代码查看下参数：\n```\n// 全局定义  绝对定位自定义指令\nVue.directive(\'abLocal\', {\n  // 指令第一次绑定到元素时\n  bind(el, binding, vnode) {\n    console.log(\"el:\", el);\n        console.log(el.style);\n        console.log(\"color:\", el.style.color);\n        console.log(\"data-id:\", el.dataset.id);\n        console.log(binding);\n        console.log(vnode);\n    el.style.position = \'absolute\';\n    el.style.top = binding.value.top+\'px\';\n    el.style.left = binding.value.left+\'px\';\n  }\n})\n```\n\n```\n<template>\n  <div id=\"app\" data-id=\"0\" style=\"color: green\"  v-abLocal=\"{top: \'50\', left: \'100\'}\">   \n    <p >\n      字段1:\n      <input data-id=\"1\" style=\"color: green\" v-model=\"info1\" v-focus>\n      字段2:\n      <input data-id=\"2\" style=\"color: green\" v-model=\"info2\" >\n    </p>\n    <p id=\"computed-example\">连接: {{ connectInfo }}</p>\n    <p id=\"filters-example\">全部大写: {{connectInfos | capitalize}}</p>\n    <Child :info=\"connectInfos\"></Child>\n  </div>\n</template> \n```\n\n参数 **el**:\n* \n![](https://user-gold-cdn.xitu.io/2020/3/8/170b94f118d41b89?w=584&h=275&f=png&s=20372)\n可以看到绝对定位的样式 **{position: absolute; top: 50px; left: 100px}**  被添加进去了\n参数 **binging**\n* \n![](https://user-gold-cdn.xitu.io/2020/3/8/170b953ca7c01145?w=601&h=157&f=png&s=12886)\n传入的值{top: \'50\', left: \'100\'} 再binding.value中拿到了。\n### 最后\n只是很浅的理解，还需要更深入的学习。文章有不妥的地方请大家指正。\n','学习理解vue的各属性，准确使用属性给我们更好的开发体验。\n新人一枚，简单的学习分享，请各位大佬指点',1600876800,1044),
(5,1,'仿网易云音乐','- # 前言\n  笔者前端小兵一枚，在学习了一段时间的小程序后，决定亲自动手做一款模仿一款手机软件来练手，自己平常也热爱音乐，并且发现各家的音乐平台的小程序都比较简单，于是就选择了这个方向来进行模仿学习，在这个过程中也遇到了很多问题，在解决这些问题后，也有了一些收获，今天就来和大家分享在这个小程序中，最难的**音乐播放**这一部分的种种问题和解决。\n\n  首先，先感谢本项目的api提供者[binaryify](https://binaryify.github.io/)  \n  选择这个项目，也是因为后端api有大佬提供了，需要数据的时候只用发起一些接口请求就可以了，比较适合像我这样的初学者入门，只用写一些简单的前端逻辑就可以了。\n\n  由于播放页面需要处理的事情较多（例如歌词的处理与展示、进度条的快进快退等等），并且坑比较多，为了尽可能的描述清楚，所以本篇文章主要着重介绍和**音乐播放**有关的种种操作，有关于本项目其他页面的详情介绍，将放在后续文章进行详细叙述，感谢各位读者大大的理解。\n  # 项目界面预览：\n\n  ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0eb907a77734ca49c0746d27bcb810b~tplv-k3u1fbpfcp-zoom-1.image)\n   # git地址\n   https://github.com/shengliangge/wxApp\n\n  云村和视频模块目前还没有开发，后续有时间就写，本项目会不定期更新，日后有时间就写一篇项目使用文档\n\n  # 正式开始\n  有关于音乐播放的几个接口请求中，几乎都需要携带**歌曲 id**，在本项目的所有页面中，播放页面作为一个独立的页面存在，当别的页面跳转到播放页面时，都会携带**歌曲 id**\n  ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a946e7079be343379b77166b75cfa7a4~tplv-k3u1fbpfcp-zoom-1.image)\n\n  ## 接口封装\n  本项目使用的接口请求有点多，为了方便，我将其封装在`utils`文件夹中的`api.js`文件中，再在页面中引用接口管理文件。\n  ```\n  // method(HTTP 请求方法)，网易云API提供get和post两种请求方式\n  const GET = \'GET\';\n  const POST = \'POST\';\n  // 定义全局常量baseUrl用来存储前缀\n  const baseURL = \'http://neteasecloudmusicapi.zhaoboy.com\';\n  \n  function request(method, url, data) {\n    return new Promise(function (resolve, reject) {\n      let header = {    //定义请求头\n        \'content-type\': \'application/json\',\n      };\n      wx.request({\n        url: baseURL + url,\n        method: method,\n        data: method === POST ? JSON.stringify(data) : data,\n        header: header,\n        success(res) {\n          //请求成功\n          //判断状态码---errCode状态根据后端定义来判断\n          if (res.data.code == 200) {  //请求成功\n            resolve(res);\n          } else {\n            //其他异常\n            reject(\'运行时错误,请稍后再试\');\n          }\n        },\n        fail(err) {\n          //请求失败\n          reject(err)\n        }\n      })\n    })\n  }\n  \n  const API = {\n    getSongDetail: (data) => request(GET, `/song/detail`, data),  //获取歌曲详情\n    getSongUrl:(data) => request(GET, `/song/url`, data),  //获取歌曲路径\n  };\n  module.exports = {\n    API: API\n  }\n  ```\n  这里只展示了两个在本页面用到的请求API，在需要接口请求的页面引入就可以使用了\n\n  `const $api = require(\'../../utils/api.js\').API;`\n\n\n  ## 音乐处理\n  ### 页面数据源\n  本页面的使用到的`data`数据源\n  ```\n    data: {\n      musicId: -1,//音乐id\n      hidden: false,  //加载动画是否隐藏\n      isPlay: true,   //歌曲是否播放\n      song: [],    //歌曲信息\n      hiddenLyric: true,    //是否隐藏歌词\n      backgroundAudioManager: {},  //背景音频对象\n      duration: \'\',             //总音乐时间（00:00格式）\n      currentTime: \'00:00\',      //当前音乐时间（00:00格式）\n      totalProcessNum: 0,         //总音乐时间 （秒）\n      currentProcessNum: 0,       //当前音乐时间（秒）\n      storyContent: [],   //歌词文稿数组，转化完成用来在页面中使用\n      marginTop: 0,    //文稿滚动距离\n      currentIndex: 0,    //当前正在第几行\n      noLyric: false,  //是否有歌词\n      slide: false   //进度条是否在滑动\n    },\n  ```\n\n\n  **其他页面跳转举例：**其他页面跳转到play页面，携带musicId参数\n  ```\n  \n    //播放音乐\n    playMusic: function (e) {\n      let musicId = e.currentTarget.dataset.in.id    // 获取音乐id\n      // 跳转到播放页面\n      wx.navigateTo({\n        url: `../play/play?musicId=${musicId}`\n      })\n    },\n  ```\n  ### onLoad生命周期\n  在`play.js`的`onLoad`生命周期函数中，通过`options`拿到其他页面传过来的`musicId`这个参数，并且调用`play()`函数\n  ```\n    /**\n     * 生命周期函数--监听页面加载\n     */\n    onLoad: function (options) {\n      const musicId = options.musicId    //获取到其他页面传来的musicId\n      this.play(musicId)    //调用play方法\n    },\n  ```\n  ### 播放函数![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53daff6e0def4d9587488276e063bd90~tplv-k3u1fbpfcp-zoom-1.image)\n  `play()`函数需要一个形参：`musicId`,这个形参非常重要，之后的接口请求都需要用到它\n\n\n  ```\n   //播放音乐\n    play(musicId) {\n      const that = this;//将this对象复制给that\n      that.setData({\n        hidden: false,\n        musicId\n      })\n      app.globalData.musicId = musicId        // 将当前音乐id传到全局\n      // 通过musicId发起接口请求，请求歌曲详细信息\n      //获取到歌曲音频，则显示出歌曲的名字，歌手的信息，即获取歌曲详情；如果失败，则播放出错。\n      $api.getSongDetail({ ids: musicId }).then(res => {\n        // console.log(\'api获取成功，歌曲详情：\', res);\n        if (res.data.songs.length === 0) {\n          that.tips(\'服务器正忙~~\', \'确定\', false)\n        } else {   //获取成功\n          app.globalData.songName = res.data.songs[0].name\n          that.setData({\n            song: res.data.songs[0],  //获取到歌曲的详细内容，传给song\n          })\n          wx.request({     // 获取歌词\n            url: \'http://47.98.159.95/m-api/lyric\',\n            data: {\n              id: musicId\n            },\n            success: res => {\n              if (res.data.nolyric || res.data.uncollected) { //该歌无歌词,或者歌词未收集\n                // console.log(\"无歌词\")\n                that.setData({\n                  noLyric: true\n                })\n              }\n              else {  //如果有歌词，先调用sliceNull()去除空行，再调用parseLyric()格式化歌词\n                that.setData({\n                  storyContent: that.sliceNull(that.parseLyric(res.data.lrc.lyric))\n                })\n              }\n            }\n          })\n          // 通过音乐id获取音乐的地址，请求歌曲音频的地址，失败则播放出错，成功则传值给createBackgroundAudioManager(后台播放管理器，让其后台播放)\n          $api.getSongUrl({ id: musicId }).then(res => {\n            //请求成功\n            if (res.data.data[0].url === null) {  //获取出现错误出错\n              that.tips(\'音乐播放出了点状况~~\', \'确定\', false)\n            } else {\n              // 调用createBackgroundAudioManager方法将歌曲url传入backgroundAudioManager\n              that.createBackgroundAudioManager(res.data.data[0]);\n            }\n          })\n            .catch(err => {\n              //请求失败\n              that.tips(\'服务器正忙~~\', \'确定\', false)\n            })\n        }\n      })\n        .catch(err => {\n          //请求失败\n          that.tips(\'服务器正忙~~\', \'确定\', false)\n        })\n    },\n  ```\n    总体大致的思路是：\n  1. 先通过musicId请求歌曲的详细信息（歌曲、歌手、歌曲图片等信息）\n  2. 在获取成功后接着获取该歌曲的歌词信息(原歌词请求地址有问题，导致这里换了一个接口，所以没封装，直接使用的`wx.request`做的请求)，请求结果如果有歌词，就将请求回来的**歌词数据**设置到数据源中的`storyContent`中，这时的歌词还没有经过处理，之后还要处理一下歌词，先调用`parseLyric()`**格式化歌词**，再调用`sliceNull()`**去除空行**。\n  如果该歌没有歌词（情况比如：钢琴曲这种纯音乐无歌词的、或者一些非常小众的个人歌曲没有上传歌词的），就设置数据源中的`noLyric`为`true`,设置了之后，页面就会显示：纯音乐，无歌词。\n   ### 点击切换歌词和封面\n\n  ![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04703453a9124f45a79b93447f554041~tplv-k3u1fbpfcp-zoom-1.image)\n  ```\n    showLyric() {\n      this.setData({\n        hiddenLyric: !this.data.hiddenLyric\n      })\n    },\n  ```\n     ### 格式化歌词\n     在请求回歌词之后，还需要对歌词进行分行处理\n     ```\n    //格式化歌词\n    parseLyric: function (text) {\n      let result = [];\n      let lines = text.split(\'\\n\'), //切割每一行\n        pattern = /\\[\\d{![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4c2ec80ed514746bdd642986f54913f~tplv-k3u1fbpfcp-zoom-1.image)2}:\\d{2}.\\d+\\]/g;//用于匹配时间的正则表达式，匹配的结果类似[xx:xx.xx]\n      // console.log(lines);\n      //去掉不含时间的行\n      while (!pattern.test(lines[0])) {\n        lines = lines.slice(1);\n      };\n      //上面用\'\\n\'生成数组时，结果中最后一个为空元素，这里将去掉\n      lines[lines.length - 1].length === 0 && lines.pop();\n      lines.forEach(function (v /*数组元素值*/, i /*元素索引*/, a /*数组本身*/) {\n        //提取出时间[xx:xx.xx]\n        var time = v.match(pattern),\n          //提取歌词\n          value = v.replace(pattern, \'\');\n        // 因为一行里面可能有多个时间，所以time有可能是[xx:xx.xx][xx:xx.xx][xx:xx.xx]的形式，需要进一步分隔\n        time.forEach(function (v1, i1, a1) {\n          //去掉时间里的中括号得到xx:xx.xx\n          var t = v1.slice(1, -1).split(\':\');\n          //将结果压入最终数组\n          result.push([parseInt(t[0], 10) * 60 + parseFloat(t[1]), value]);\n        });\n      });\n      // 最后将结果数组中的元素按时间大小排序，以便保存之后正常显示歌词\n      result.sort(function (a, b) {\n        return a[0] - b[0];\n      });\n      return result;\n    },\n     ```\n     ### 歌词去除空白行\n\n    ```\n      sliceNull: function (lrc) {\n        var result = []\n        for (var i = 0; i < lrc.length; i++) {\n          if (lrc[i][1] !== \"\") {\n            result.push(lrc[i]);\n          }\n        }\n        return result\n      },\n    ```\n  3. 再接着通过id去获取歌曲的播放路径，获取到音频的数据源后，则调用\n  `createBackgroundAudioManager()`函数，传入刚刚获取到的音频数据源。（下文详细介绍）\n\n  4. 如果其中的任意一个环节出现了问题，则会弹出提示信息，调用tips()函数,并返回主页\n\n    ### 友好提示\n    - 播放页面接口请求较多，并且调用频繁，加上一些网络波动，接口调用难免会出现一些失败的情况，为了给用户一些更好的反馈和提示，就使用了微信官方的显示模态对话框`wx.showModal`,写成了一个`tips()`函数，在想给提示对话框的时候，直接调用`tips()`函数就可以，在出现错误之后，用户点击确定会触发回调函数中的`res.confirm`判断，然后回到首页，这里因为网易云手机app的导航在头部，所以我是用的自定义组件做的导航，没有使用 `tabBar`,页面跳转用的`wx.navigateTo()`,如果大家使用了`tabBar`,那么跳转就应该换成`wx.switchTab()`\n    ```\n    tips(content, confirmText, isShowCancel) {\n      wx.showModal({\n        content: content,\n        confirmText: confirmText,\n        cancelColor: \'#DE655C\',\n        confirmColor: \'#DE655C\',\n        showCancel: isShowCancel,\n        cancelText: \'取消\',\n        success(res) {\n          if (res.confirm) {\n            // console.log(\'用户点击确定\')\n            wx.navigateTo({\n              url: \'/pages/find/find\'\n            })\n          } else if (res.cancel) {\n            // console.log(\'用户点击取消\')\n          }\n        }\n      })\n    },\n    ```\n    - 接口的请求需要一些时间，在切歌、请求各类数据、页面加载时都有一段时间的等待期，为了提高用户的友好性，在加载时最好加上一些等待动画，我这里就直接使用的比较简单的方法，在wxml中加上一个`loading`标签，通过数据源中的`hidden`,来控制`loading`动画是否显示，一开始设置为`false`，，然后在数据请求完成后，将其更改为`true`。\n    \n\n  wxml中：\n  ```\n    <loading hidden=\"{{hidden}}\">\n  		拼命加载中...\n    </loading>\n  ```\n\n     ## 音频播放\n    上面提到，在接口请求回音频路径之后，就会调用这个函数，把请求会的数据作为参数传过来，那现在就来剖析这个函数吧。\n    ```\n     // 背景音频播放方法\n    createBackgroundAudioManager(res) {\n      const that = this;//将this对象复制给that\n      const backgroundAudioManager = wx.getBackgroundAudioManager(); //调用官方API获取全局唯一的背景音频管理器。\n      console.log(backgroundAudioManager.src);\n      if (res.url != null) {\n        if (backgroundAudioManager.src != res.url) {    //首次放歌或者切歌\n         that.setData({     //重设一下进度，避免切歌部分数据更新过慢\n            currentTime: \'00:00\',      //当前音乐时间（00:00格式）\n            currentProcessNum: 0,       //当前音乐时间（秒）\n            marginTop: 0,    //文稿滚动距离\n            currentIndex: 0,    //当前正在第几行\n          })\n          backgroundAudioManager.title = that.data.song.name;                //把title音频标题给实例\n          backgroundAudioManager.singer = that.data.song.ar[0].name;             //音频歌手给实例\n          backgroundAudioManager.coverImgUrl = that.data.song.al.picUrl;         //音频图片 给实例\n          backgroundAudioManager.src = res.url;        // 设置backgroundAudioManager的src属性，音频会立即播放\n          let musicId = that.data.musicId\n          app.globalData.history_songId = that.unique(app.globalData.history_songId, musicId) //去除重复历史\n        }\n        that.setData({\n          isPlay: true,  //是否播放设置为true\n          hidden: true,  //隐藏加载动画\n          backgroundAudioManager\n        })\n      }\n      app.globalData.backgroundAudioManager = backgroundAudioManager\n      //监听背景音乐进度更新事件\n      backgroundAudioManager.onTimeUpdate(() => {\n        that.setData({\n          totalProcessNum: backgroundAudioManager.duration,\n          currentTime: that.formatSecond(backgroundAudioManager.currentTime),\n          duration: that.formatSecond(backgroundAudioManager.duration)\n        })\n        if (!that.data.slide) {    //如果进度条在滑动，就暂停更新进度条进度，否则会出现进度条进度来回闪动\n          that.setData({\n            currentProcessNum: backgroundAudioManager.currentTime,\n          })\n        }\n        if (!that.data.noLyric) {   //如果没有歌词，就不需要调整歌词位置\n          that.lyricsRolling(backgroundAudioManager)\n        }\n      })\n      backgroundAudioManager.onEnded(() => {  //监听背景音乐自然结束事件，结束后自动播放下一首。自然结束，调用go_lastSong()函数，即歌曲结束自动播放下一首歌\n        that.nextSong();\n      })\n    },\n    ```\n    音频播放函数里面的逻辑相对比较复杂，大致思路如下：\n\n    1. 首先先创建一个`BackgroundAudioManager` 实例，通过 `wx.getBackgroundAudioManager` 获取。\n      然后这里就需要做一个判断，因为当调用本方法有几种情况，一是首次放歌或切换歌曲、二是进来没切换歌曲，所以要判断当前音乐id获取url地址是否等于`backgroundAudioManager.src`，如果不相等，那就是第一种情况，需要将歌曲的`musicId`调用`unique()`去重方法，存入全局的`history_songId[]`，这个**历史歌单**主要用来给用户切换上一首歌曲用的，后面会详细讲\n      然后给实例设置`title`、`singer`、`coverImgURL`、`src`、当设置了新的 `src` 时，音乐会自动开始播放，设置这些属性，主要用于原生音频播放器的显示以及分享，（注意title必须设置），设置之后，在手机上使用小程序播放音乐，就会出现一个原生音频播放器，如图：\n\n  ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a43b5a35ee884a48a2bde08795d3f806~tplv-k3u1fbpfcp-zoom-1.image)\n  ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/597f2d9a82b147e2a4b078d56a9acbaa~tplv-k3u1fbpfcp-zoom-1.image)\n  感觉还不错，可惜的是，好像一直目前为止，这个原生的音频播放器都不能设置歌词，只能设置一下基本属性，这也是一个小遗憾，希望微信团队日后能够完善它。\n   ### 历史歌单去重\n   作用：用户每播放一首歌，就将其存入历史列表中，在存入之前，先判断这首歌是否已经存在，如果不存在，直接存入到历史歌单数组后面，如果这首歌已经存在，那就先去除老记录，存入新纪录。\n    ```\n      // 历史歌单去重\n    unique(arr, musicId) {\n      let index = arr.indexOf(musicId)  //使用indexOf方法，判断当前musicId是否已经存在，如果存在，得到其下标\n      if (index != -1) {          //如果已经存在在历史播放中，则删除老记录，存入新记录\n        arr.splice(index, 1)\n        arr.push(musicId)\n      } else {\n        arr.push(musicId)       //如果不存在，则直接存入历史歌单\n      }\n      return arr  //返回新的数组\n    },\n    ```\n  2. 第二步就是更新数据源的一些数据，操作和作用都比较简单，就不详讲了\n  3. 第三步就很重要了，使用 `backgroundAudioManager.onTimeUpdate()`监听背景音乐的进度更新，页面进度条的秒数更新就和这有关!![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aac143c7b91d434f969656ab78e80fb5~tplv-k3u1fbpfcp-zoom-1.image)[](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/900bc68a99194ad0bf8735c6b4de9f5c~tplv-k3u1fbpfcp-zoom-1.image)\n  wxml：\n  ```\n  <view class=\"page-slider\">\n  			<view>\n  				{{currentTime}}\n  			</view>\n  			<slider class=\"slider_middle\" bindchange=\"end\" bindtouchstart=\"start\" max=\"{{totalProcessNum}}\" min=\"0\" backgroundColor=\"rgba(255,255,255,.3)\"\n   activeColor=\"rgba(255,255,255,.8)\"	 value=\"{{currentProcessNum}}\" block-size=\"12\"></slider>\n  			<view>\n  				{{duration}}\n  			</view>\n  		</view>\n  ```\n  `backgroundAudioManager.currentTime`和`backgroundAudioManager.currentTime`分别会返回音频播放位置和音频长度，单位为秒，而进度条左边的当前时间和右边的歌曲总时长需要显示成00:00的格式，所以使用`formatSecond()`来格式化秒数\n  ### 格式化时间\n  ```\n    // 格式化时间\n    formatSecond(second) {\n      var secondType = typeof second;\n      if (secondType === \"number\" || secondType === \"string\") {\n        second = parseInt(second);\n        var minute = Math.floor(second / 60);\n        second = second - minute * 60;\n        return (\"0\" + minute).slice(-2) + \":\" + (\"0\" + second).slice(-2);\n      } else {\n        return \"00:00\";\n      }\n    },\n  ```\n  ### 歌词滚动\n\n  ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49dd7157e759442b8630dfe637493ab1~tplv-k3u1fbpfcp-zoom-1.image)\n  wxml:\n  ```\n  		<!-- 歌词 -->\n  		<!-- 需要设置高度，否则scroll-top可能失效 -->\n  		<scroll-view\n  		 hidden=\"{{hiddenLyric}}\"\n  		 scroll-y=\"true\"\n  		 scroll-with-animation=\'true\'\n  		 scroll-top=\'{{marginTop}}\'\n  		 class=\"body-scroll\"\n  		>\n  			<view class=\'contentText\'>\n  				<view class=\"contentText-noLyric\" wx:if=\"{{noLyric==true}}\">纯音乐，无歌词 </view>\n  				<block wx:for=\'{{storyContent}}\' wx:key=\"index\">\n  					<view class=\"lyric\">\n  						<view class=\"lyric-text {{currentIndex == index ? \'currentTime\' : \'\'}}\">{{item[1]}}</view>\n  					</view>\n  				</block>\n  			</view>\n  		</scroll-view>\n  ```\n  - 歌词的随屏滚动通过歌词时间和音频当前位置来判断当前歌词是多少行，自动滚动是用行数来计算高度，通过设置数据源的`marginTop`,这个值作用于`scroll-view`的`scroll-top`,实现自动滚动的，需要注意的是，`scroll-view`需要设置高度，否则`scroll-top`可能失效\n  - 通过判断`currentIndex`是否和页面for循环中的index值是否相等，来给当前唱的歌词加上类名，使其高亮显示。\n  ```\n   // 歌词滚动方法\n    lyricsRolling(backgroundAudioManager) {\n      const that = this\n      // 歌词滚动\n      that.setData({\n        marginTop: (that.data.currentIndex - 3) * 39\n      })\n      // 当前歌词对应行颜色改变\n      if (that.data.currentIndex != that.data.storyContent.length - 1) {//不是最后一行\n        // var j = 0;\n        for (let j = that.data.currentIndex; j < that.data.storyContent.length; j++) {\n          // 当前时间与前一行，后一行时间作比较， j:代表当前行数\n          if (that.data.currentIndex == that.data.storyContent.length - 2) {  //倒数第二行\n            //最后一行只能与前一行时间比较\n            if (parseFloat(backgroundAudioManager.currentTime) > parseFloat(that.data.storyContent[that.data.storyContent.length - 1][0])) {\n              that.setData({\n                currentIndex: that.data.storyContent.length - 1\n              })\n              return;\n            }\n          } else {\n            if (parseFloat(backgroundAudioManager.currentTime) > parseFloat(that.data.storyContent[j][0]) && parseFloat(backgroundAudioManager.currentTime) < parseFloat(that.data.storyContent[j + 1][0])) {\n              that.setData({\n                currentIndex: j\n              })\n              return;\n            }\n          }\n        }\n      }\n    },\n  ```\n  ### 进度条事件\n  在进度条开始滑动的时候将数据源中的`slide`设置为true，这时`backgroundAudioManager.onTimeUpdate()`中的更新数据源`currentProcessNum`就不会再进行，这样就缓解了进度条抖动的问题。\n\n  **抖动问题**：如图，在拖动进度条想快进或者快退音乐的时候，可以看到小滑块非常明显的抖动，这是由于`onTimeUpdate()`在不停的监听并更改数据源中的`currentProcessNum`，导致拖动过程中的小滑块不停的前后跳动。\n  ![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f252b4c3cfc4e23abc17bcbaa2dba86~tplv-k3u1fbpfcp-zoom-1.image)\n  ```\n  //进度条开始滑动触发\n    start: function (e) {\n      // 控制进度条停，防止出现进度条抖动\n      this.setData({\n        slide: true\n      })\n    },\n  ```\n\n    结束滑动的时候，通过`backgroundAudioManager.seek(position)`来让音频跳到**指定位置**，然后判断当前歌词到了多少行，立马设置数据源中的`currentIndex`,让歌词就会在上面的歌词跳转方法中改变`marginTop`的值，歌词就会跳转到相应的位置。\n\n    ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88f2afa0ed6b41b6991bf57954f5a785~tplv-k3u1fbpfcp-zoom-1.image)\n    ```\n    //结束滑动触发\n    end: function (e) {\n      const position = e.detail.value\n      let backgroundAudioManager = this.data.backgroundAudioManager  //获取背景音频实例\n      // console.log(position)\n      backgroundAudioManager.seek(position) //改变歌曲进度\n      this.setData({\n        currentProcessNum: position,\n        slide: false\n      })\n      // 判断当前是多少行\n      for (let j = 0; j < this.data.storyContent.length; j++) {\n        // console.log(\'当前行数\', this.data.currentIndex)\n        // console.log(parseFloat(backgroundAudioManager.currentTime))\n        // console.log(parseFloat(this.data.storyContent[j][0]))\n        // 当前时间与前一行，后一行时间作比较， j:代表当前行数\n        if (position < parseFloat(this.data.storyContent[j][0])) {\n          this.setData({\n            currentIndex: j - 1\n          })\n          return;\n        }\n      }\n    }\n    ```\n  4. 第四步使用`backgroundAudioManager.onEnded()`监听背景音乐的自然结束，结束就调用`nextSong()`函数,这个函数用来播放待放列表里面的歌。\n  ### 播放上一首、播放下一首\n  ![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b8b140b5f624a6494b870cdd0b2c1c3~tplv-k3u1fbpfcp-zoom-1.image)\n  播放前一首歌，那么现在这首歌就变成了下一首要放的歌，因为每一首当前播放的歌曲都会放到被`push()`到历史列表，那么将当前歌曲（把历史列表数组里面的最后一项从数组删除，并将其**头插**加入到待播放列表）放入待放歌单，然后调用`play()`方法就好了(传入删除了最后一项之后新的历史列表数组的最后一项，即原历史列表的倒数第二项) \n  ```\n    // 播放上一首歌曲\n    beforeSong() {![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d07ee4e5583d49b482f2046481c70053~tplv-k3u1fbpfcp-zoom-1.image)\n      if (app.globalData.history_songId.length > 1) {  //前面有歌\n        app.globalData.waitForPlaying.unshift(app.globalData.history_songId.pop())//将当前播放歌曲从前插入待放列表\n        this.play(app.globalData.history_songId[app.globalData.history_songId.length - 1])  //播放历史歌单歌曲\n      } else {\n        this.tips(\'前面没有歌曲了哦\', \'去选歌\', true)\n      }\n    },\n  ```\n  播放下一首歌曲，如果待播放列表数组长度大于0，那就把数组第一个元素删除并返回传入到`play()`方法中\n  ```\n    // 下一首歌曲\n    nextSong() {\n      if (app.globalData.waitForPlaying.length > 0) {\n        this.play(app.globalData.waitForPlaying.shift())//删除待放列表第一个元素并返回播放\n      } else {\n        this.tips(\'后面没有歌曲了哦\', \'去选歌\', true)\n      }\n    },\n  ```\n  ### 暂停和播放\n  比较简单，拿到数据原中的`backgroundAudioManager`,通过其自带的`pause()`、`play()`的方法就可以实现播放和暂停\n  ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ec6f8094e804c4cbc928a290b066bef~tplv-k3u1fbpfcp-zoom-1.image)\n  ```\n    // 播放和暂停\n    handleToggleBGAudio() {\n      const backgroundAudioManager = this.data.backgroundAudioManager\n      //如果当前在播放的话\n      if (this.data.isPlay) {\n        backgroundAudioManager.pause();//暂停\n      } else {      //如果当前处于暂停状态\n        backgroundAudioManager.play();//播放\n      }\n      this.setData({\n        isPlay: !this.data.isPlay\n      })\n    },\n  ```\n\n  # 总结\n  本项目并不复杂，适合初学者上手，因为免去了写复杂的后端，只用写好js逻辑就可以，并且在听到自己仿的小程序可以放出音乐的时候会有很大的成就感，但是同时还是存在一些小坑等待大家处理的，在写本小程序的时候，我也是遇到了挺多问题的，遇到问题先思考，想不出来，就去看看别的大佬写的经验分享，由于本人经验不是特别丰富，只是浅浅入门，很多问题的解决思考的并不到位，如果个位发现我在代码中有什么bug，欢迎个位读者大大指出，期待我们的共同成长。\n\n  **本项目只是用来练习巩固知识使用，绝不作为商用，如有侵权，请联系我做整改**\n\n  另外，如果有掘友喜欢的话，后续我再详细介绍一下本项目的整体开发，例如首页的组件化开发、搜索、登陆等等。感谢各位看到这里，如果不嫌麻烦的话，不妨动动手指为我点个赞吧，谢谢啦！\n','微信小程序',1600876800,1100),
(6,2,'顺丰大概','是德国','是德国',1598889600,1002),
(7,1,'角度上看附件','\n### 是看得见\n* 节点','手动',1598889600,1040);

/*Table structure for table `type` */

DROP TABLE IF EXISTS `type`;

CREATE TABLE `type` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `typeName` varchar(255) NOT NULL,
  `orderNum` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

/*Data for the table `type` */

insert  into `type`(`id`,`typeName`,`orderNum`) values 
(1,'学习分享',1),
(2,'生活趣事',2);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
